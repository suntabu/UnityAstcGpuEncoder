// #define HAS_ALPHA 1
// #pragma multi_compile _ BLOCK_SIZE_4x4 BLOCK_SIZE_5x5 BLOCK_SIZE_6x6 BLOCK_SIZE_8x8 BLOCK_SIZE_10x10 BLOCK_SIZE_12x12
// #pragma kernel CSMain
//
// #include "ASTC_Encode.hlsl"
// #include "ASTC_Config.hlsl"
//
// // RWTexture2D<uint4> Result;
// Texture2D<float4> _BaseTexture;
// SamplerState sampler_BaseTexture;
// uint2 CompressSize;
//
// // 在 Shader 中定义线程组大小（与 numthreads 一致）
// #define THREAD_GROUP_SIZE_X 8
// #define THREAD_GROUP_SIZE_Y 8
//
// uint astcBlock;
// uint blockCountX;
// uint blockCountY;
// int isLinear;
//
// // 新增：输出 ASTC 块的缓冲区
// RWStructuredBuffer<uint4> OutputBuffer : register(u1); // 每个 uint4 = 16 bytes
//
// inline half3 LinearToGammaSpace (half3 linRGB)
// {
//     linRGB = max(linRGB, half3(0.h, 0.h, 0.h));
//     return max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);
// }
//
// // UV是Block最左下角的位置
// void ReadBlockRGBA(Texture2D<float4> SourceTexture, SamplerState TextureSampler, int mipLevel, float2 UV, float2 TexelUVSize, out float4 Block[BLOCK_SIZE])
// {
//     [unroll]
//     for (int y = 0; y < DIM; ++y)
//     {
//         [unroll]
//         for (int x = 0; x < DIM; ++x)
//         {
//             float4 targetColor = SourceTexture.SampleLevel(TextureSampler, UV + float2(x, y) * TexelUVSize, mipLevel).rgba;
//             if (isLinear == 1)
//             {
//                 targetColor.rgb = LinearToGammaSpace(targetColor.rgb);
//             }
//             Block[DIM * y + x] = targetColor * 255.0f;
//         }
//     }
// }
//
// [numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)]
// void CSMain(uint3 DispatchID : SV_DispatchThreadID)
// {
//     uint2 BlockID = DispatchID.xy;
//
//     if (BlockID.x >= blockCountX || BlockID.y >= blockCountY)
//         return;
//
//     uint2 SamplePos = BlockID * DIM;
//     if (any(SamplePos >= CompressSize.xy))
//         return;
//
//     float2 TexelUVSize = 1.f / float2(CompressSize.xy);
//     float2 SampleUV = (float2(SamplePos) + 0.5f) * TexelUVSize;
//
//     float4 texels[BLOCK_SIZE];
//     ReadBlockRGBA(_BaseTexture, sampler_BaseTexture, 0, SampleUV, TexelUVSize, texels);
//
//     uint4 compressResult = encode_block(texels);
//
//     // uint4 compressResult = uint4(BlockID.x % 255, BlockID.y % 255, 0, 255); // 固定颜色用于测试
//     // Result[BlockID] = compressResult;
//     OutputBuffer[BlockID.y * blockCountX + BlockID.x] = compressResult;
// }
//
